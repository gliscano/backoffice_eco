REQUEST CON MANEJO DE ERRORES
async requestPost(){
    this.userData = this.props.userData;
    const currentDate = this.state.selectedDate;
    
    let requestUrl = APP_CONFIG.API_ENDPOINT_URL;
    requestUrl += APP_CONFIG.API_ENDPOINT_FUTURE_PLAYS;
    
    const params = JSON.stringify({
      "date": currentDate,
      "operator_id": this.userData.operatorId,
    });

    let headers = {};
    headers = new Headers({
      'Content-Type': 'application/json',
      'Authorization': `JWT ${this.userData.token}`,
    });

    await fetch(requestUrl, {
      method: 'POST',
      body: params,
      headers,
    })
      .then((response) => {
        switch (response.status) {
          case 200:
          case 400:
            // VALID RESPONSE
            return response;
        
          case 401:
            // Unauthorized access
            this.props.history.push('/');
            break;
        
          default:
            // Another status, send unexpected error
            this.processErrors(0);
            break;
        }
      
        return false;
      })
      .then((response) => response.json())
      .then((resp) => {
        // Check status for errors
        if (resp.errors && resp.errors.length) {        
          // Get Error code
          const errorCode = resp.errors[0] && resp.errors[0].code ? resp.errors[0].code : 0;
          this.processErrors(errorCode);
          return;
        }
      
        if (resp.future_plays && resp.future_plays.length) {
          this.setState({
            serverData: resp.future_plays,
            raffleMessage: '',
          });
        
          this.processData();
        }
      })
      .catch((error) => {
        console.log('Error');
        console.log(error);
        this.setState({
          raffleMessage: `Error: ${error}`,
        });
      });
  }